サンプルコードと結果のログとなります。

# CPCS: 発音座標
class CPCS:
    def __init__(self, x=0, y=0, z=0):
        self.x = x
        self.y = y
        self.z = z

# SCS: 意味座標
class SCS:
    def __init__(self, theta=0, r=0, z=0, emotion=0):
        self.theta = theta
        self.r = r
        self.z = z
        self.emotion = emotion

# SCF: 文脈属性（32bit）
class SCF:
    def __init__(self, speaker=0, type=0, nest=0, time=0, space=0, topic=0):
        self.speaker = speaker
        self.type = type
        self.nest = nest
        self.time = time
        self.space = space
        self.topic = topic

# 単語構造
class WordEntry:
    def __init__(self, text, cpcs, scs, scf, word_id=0):
        self.text = text
        self.cpcs = cpcs
        self.scs = scs
        self.scf = scf
        self.word_id = word_id

# 仮辞書（WordID: 0x0001?）
dictionary = {
    "明日": WordEntry("明日", CPCS(50,100,0), SCS(10,50,0,0), SCF(1,0,0,1,0,0), 0x0001),
    "雨": WordEntry("雨", CPCS(30,120,0), SCS(12,40,0,0), SCF(1,0,0,1,0,0), 0x0002),
    "降る": WordEntry("降る", CPCS(60,110,5), SCS(10,55,0,0), SCF(1,0,0,1,0,0), 0x0003),
}

def euclidean_distance(c1, c2):
    return ((c1.x-c2.x)**2 + (c1.y-c2.y)**2 + (c1.z-c2.z)**2) ** 0.5

def semantic_distance(s1, s2):
    d_theta = min(abs(s1.theta - s2.theta), 256 - abs(s1.theta - s2.theta))
    d_r = abs(s1.r - s2.r)
    d_z = abs(s1.z - s2.z)
    return (d_theta + d_r + d_z)/3

def total_distance(w1, w2, w_phon=0.6, w_sem=0.4):
    return w_phon*euclidean_distance(w1.cpcs, w2.cpcs) + w_sem*semantic_distance(w1.scs, w2.scs)

def correct_word(input_word):
    if input_word in dictionary:
        return dictionary[input_word]
    # 未登録語: 仮ID生成
    return WordEntry(input_word, CPCS(), SCS(), SCF(), word_id=0xFFFF)

sentence = ["明日", "は", "雨", "が", "降る"]
processed = []

for word in sentence:
    entry = correct_word(word)
    processed.append(entry)

# 結果表示
for e in processed:
    print(f"Word: {e.text}, ID: {hex(e.word_id)}, CPCS:({e.cpcs.x},{e.cpcs.y},{e.cpcs.z}), "
          f"SCS:({e.scs.theta},{e.scs.r},{e.scs.z}), SCF speaker:{e.scf.speaker}")

# 入力単語: 「あめ」
input_word = "あめ"
# 類似語探索
distances = [(w.text, total_distance(WordEntry(input_word, CPCS(30,120,0), SCS(12,40,0), SCF(1,0,0,1,0,0)), w))
             for w in dictionary.values()]
distances.sort(key=lambda x: x[1])
print("候補:", distances[:3])

上記テストコードを実行すると以下のような結果になりります。
未登録語（「は」「が」）は 0xFFFF で初期化され、CPCS/SCS/SCF はゼロになっている
登録済み語（「明日」「雨」「降る」）は、設定した座標や属性が正しく反映されている
類似語検索も total_distance によって正しく距離計算され、最も近い語が候補リストの先頭に来ている

=== LCB辞書動作テストログ ===
実行環境: Windows10 / Python 3.x
日付: 2025-11-11

入力文:
["明日", "は", "雨", "が", "降る"]

出力:
Word: 明日, ID: 0x1, CPCS:(50,100,0), SCS:(10,50,0), SCF speaker:1
Word: は, ID: 0xffff, CPCS:(0,0,0), SCS:(0,0,0), SCF speaker:0
Word: 雨, ID: 0x2, CPCS:(30,120,0), SCS:(12,40,0), SCF speaker:1
Word: が, ID: 0xffff, CPCS:(0,0,0), SCS:(0,0,0), SCF speaker:0
Word: 降る, ID: 0x3, CPCS:(60,110,5), SCS:(10,55,0), SCF speaker:1

類似語検索テスト:
入力: "あめ"（仮発音: CPCS(30,120,0), SCS(12,40,0)）

候補:
[('雨', 0.0), ('明日', 18.57056274847714), ('降る', 21.47603937896521)]
